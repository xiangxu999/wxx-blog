---
title: Redis核心技术16-删除数据后内存占用率还是很高
date: 2023-03-31 12:48:27
permalink: /pages/3bc59a/
categories: 
  - Redis
tags: 
  - Redis
---
## Redis核心技术16-删除数据后内存占用率还是很高

当数据删除后，Redis释放的内存空间会由内存分配器管理，并不会立即返回给操作系统。所以，操作系统仍然会记录着给 Redis 分配了大量内存。

但是这样就存在一个问题：虽然有空闲空间，Redis却无法用来保存数据，不仅会减少Redis能够实际保存的数据量，还会降低Redis运行机器的成本回报率。

## 内存碎片

通常情况下，内存空间闲置，往往是因为操作系统发生了较为严重的内存碎片。

内存碎片：就好比一个大教室中那些零散的位置。而应用程序申请的是一块连续地址空间的N字节，但在剩余的内存空间中，没有大小为 N 字节的连续空间了，那么，这些剩余空间就是内存碎片

## 内存碎片如何形成

### 内因：内存分配器的分配策略

内存分配器的分配策略就决定了操作系统无法做到“按需分配”。这是因为，内存分配器一般是按固定大小来分配内存，而不是完全按照应用程序申请的内存空间大小给程序分配。

以jemalloc的分配内存为例，它是按照一系列固定的大小划分内存空间，例如 8 字节、16 字节、32 字节、48 字节，…, 2KB、4KB、8KB 等。Redis申请一个20字节的空间保存数据，jemalloc就会分配32字节。

### 外因：键值对大小不一样和删改操作

**外因一**

Redis 通常作为共用的缓存系统或键值数据库对外提供服务，所以，不同业务应用的数据都可能保存在 Redis 中，这就会带来不同大小的键值对。这样一来，Redis 申请内存空间分配时，本身就会有大小不一的空间需求。由于本身内存分配器只能按照固定大小分配内存，所以，分配的内存空间一般都会比申请的空间大一些，不会完全一致，这本身就会造成一定的碎片，降低内存空间存储效率。

**外因二**

键值对会被修改和删除，就会导致空间的扩容和释放。具体来说，一方面，如果修改后的键值对变大或变小了，就需要占用额外的空间或者释放不用的空间。另一方面，删除的键值对就不再需要内存空间了，此时，就会把空间释放出来，形成空闲空间。

![image-20220819093412229](https://blog-1300853183.cos.ap-chengdu.myqcloud.com/img/image-20220819093412229.png)

从上图可以发现，在第三步的时候为了保存A数据的空间连续性，操作系统就需要把B的数据拷贝到别的空间，当应用C和应用D分别进行删除字节的时候，整个内存空间上就分别出现了 2 字节和 1 字节的空闲碎片。此时如果来一个新应用E想要3个字节的连续空间，显然是不行的。

## 如何判断存在内存碎片

Redis 是内存数据库，内存利用率的高低直接关系到 Redis 运行效率的高低。为了让用户能监控到实时的内存使用情况，Redis 自身提供了 INFO 命令，可以用来查询内存使用的详细信息：

```
> INFO memory
# Memory
used_memory:727584
used_memory_human:710.53K
used_memory_rss:690672
used_memory_rss_human:674.48K
used_memory_peak:728552
used_memory_peak_human:711.48K
total_system_memory:0
total_system_memory_human:0B
used_memory_lua:37888
used_memory_lua_human:37.00K
maxmemory:0
maxmemory_human:0B
maxmemory_policy:noeviction
mem_fragmentation_ratio:0.95
mem_allocator:jemalloc-3.6.0
```

- mem_fragmentation_ratio：表示Redis当前的内存碎片率（used_memory_rss/ used_memory）
- used_memory_rss：操作系统实际分配给 Redis 的物理内存空间，里面就包含了碎片
- used_memory：Redis 为了保存数据实际申请使用的空间。

当mem_fragmentation_ratio 大于 1.5 。这表明内存碎片率已经超过了 50%。一般情况下，这个时候，我们就需要采取一些措施来降低内存碎片率了。

## 如何清理内存碎片

最“简单粗暴”的方法就是重启 Redis 实例。当然，这并不是一个“优雅”的方法，毕竟，重启 Redis 会带来两个后果：

- 如果 Redis 中的数据没有持久化，那么，数据就会丢失；
- 即使 Redis 数据持久化了，我们还需要通过 AOF 或 RDB 进行恢复，恢复时长取决于 AOF 或 RDB 的大小，如果只有一个 Redis 实例，恢复阶段无法提供服务。

现在试想一下，如果高铁上有两个不连续的位置，你和好朋友想要坐一起，就可以通过和其他人沟通的方式来进行换位。内存碎片清理，也可以通过这样的方式。当有数据把一块连续的内存空间分割成好几块不连续的空间时，操作系统就会把数据拷贝到别处。此时，数据拷贝需要能把这些数据原来占用的空间都空出来，把原本不连续的内存空间变成连续的空间。否则，如果数据拷贝后，并没有形成连续的内存空间，这就不能算是清理了。

![image-20220819094531026](https://blog-1300853183.cos.ap-chengdu.myqcloud.com/img/image-20220819094531026.png)

> 内存清理是存在代价的，操作系统需要把多份数据拷贝到新位置，把原有空间释放出来，这会带来时间开销。因为 Redis 是单线程，在数据拷贝时，Redis 只能等着，这就导致 Redis 无法及时处理请求，性能就会降低。

我们可以通过设置参数，来控制碎片清理的开始和结束时机，以及占用的 CPU 比例，从而减少碎片清理对 Redis 本身请求处理的性能影响。

启动自动内存碎片清理：

```

config set activedefrag yes
```

设置什么时候清理：

- active-defrag-ignore-bytes 100mb：表示内存碎片的字节数达到 100MB 时，开始清理；
- active-defrag-threshold-lower 10：表示内存碎片空间占操作系统分配给 Redis 的总空间比例达到 10% 时，开始清理。

控制清理操作占用CPU时间比例的上下限，既保证清理工作能正常进行，又避免了降低 Redis 性能：

- active-defrag-cycle-min 25： 表示自动清理过程所用 CPU 时间的比例不低于 25%，保证清理能正常开展；
- active-defrag-cycle-max 75：表示自动清理过程所用 CPU 时间的比例不高于 75%，一旦超过，就停止清理，从而避免在清理时，大量的内存拷贝阻塞 Redis，导致响应延迟升高。

## 参考

[Redis核心技术与实战](https://time.geekbang.org/column/intro/100056701?tab=catalog)