---
title: MySQL深入29-查询对内存的影响
date: 2023-03-31 12:45:34
permalink: /pages/486875/
categories: 
  - MySQL
tags: 
  - MySQL
---
## MySQL深入29-查询对内存的影响

如果一个内存较小的主机对一个大表做全表扫描，会不会把数据库主机的内存用光了？

## 全表扫描对server层的影响

假设，我们要对一个200G的InnoDB表db1.t，执行一个全表扫描，并把结果保存在客户端：

```
mysql -h$host -P$port -u$user -p$pwd -e "select * from db1.t" > $target_file
```

InnoDB的数据是保存在主键索引上的，所以全表扫描实际上是直接扫描表t的主键索引。同时由于没有其他的判断条件，所以查到的每一行都可以直接放到结果集里面，返回客户端。

实际上，服务端并不需要保存一个完整的结果集。取数据和发数据的流程如下：

1. 获取一行，写到 net_buffer 中。这块内存的大小是由参数 net_buffer_length 定义的，默认是 16k。
2. 重复获取行，直到 net_buffer 写满，调用网络接口发出去。
3. 如果发送成功，就清空 net_buffer，然后继续取下一行，并写入 net_buffer。
4. 如果发送函数返回 EAGAIN 或 WSAEWOULDBLOCK，就表示本地网络栈（socket send buffer）写满了，进入等待。直到网络栈重新可写，再继续发送。

![image-20220701092116211](https://blog-1300853183.cos.ap-chengdu.myqcloud.com/img/image-20220701092116211.png)

在这个流程中，我们可以分析到：

- 一个查询在发送过程中，占用的 MySQL 内部的内存最大就是 net_buffer_length 这么大
- socket send buffer也不会无线大，如果socket send buffer被写满，就会暂停读数据的流程。

也就是说，MySQL是“边读边发的”，意味着如果客户端接收得慢，会导致MySQL服务端由于结果发不出去，这个事务的执行时间变长。

## 全表扫描对InnoDB的影响

InnoDB内存管理用的是最近最少使用（LRU）算法，这个算法核心就是淘汰最久未使用的数据。

![image-20220701093933362](https://blog-1300853183.cos.ap-chengdu.myqcloud.com/img/image-20220701093933362.png)

InnoDB管理Buffer Pool的LRU算法使用链表来实现的：

- 链表头部是 P1，表示 P1 是最近刚刚被访问过的数据页；假设内存里只能放下这么多数据页；
- 这时候有一个读请求访问 P3，因此变成状态 2，P3 被移到最前面；
- 状态 3 表示，这次访问的数据页是不存在于链表中的，所以需要在 Buffer Pool 中新申请一个数据页 Px，加到链表头部。但是由于内存已经满了，不能申请新的内存。于是，会清空链表末尾 Pm 这个数据页的内存，存入 Px 的内容，然后放到链表头部。
- 从效果上看，就是最久没有被访问的数据页 Pm，被淘汰了。

但是这种传统算法在做全表扫描的时候会存在问题，假设按照这个算法取扫描一个大表，而这个表是一个历史数据表，平时没有业务访问。

那么，按照这个算法扫描的话，就会把当前的 Buffer Pool 里的数据全部淘汰掉，再存入扫描过程中访问到的数据页的内容。也就是说 Buffer Pool 里面主要放的是这个历史数据表的数据。这会导致Buffer Pool的内存命中率急剧下降，磁盘压力增加，SQL 语句响应变慢。

InnoDB改进的LRU算法：

![image-20220701095143038](https://blog-1300853183.cos.ap-chengdu.myqcloud.com/img/image-20220701095143038.png)

在InnoDB实现上，按照5:3 的比例把整个 LRU 链表分成了 young 区域和 old 区域。图中 LRU_old 指向的就是 old 区域的第一个位置，是整个链表的 5/8 处。也就是说，靠近链表头部的 5/8 是 young 区域，靠近链表尾部的 3/8 是 old 区域。

改进的LRU算法流程如下：

1. 要访问数据页 P3，由于 P3 在 young 区域，因此和优化前的 LRU 算法一样，将其移到链表头部，变成状态 2。
2. 之后要访问一个新的不存在于当前链表的数据页，这时候依然是淘汰掉数据页 Pm，但是新插入的数据页 Px，是放在 LRU_old 处。
3. 处于 old 区域的数据页，每次被访问的时候都要做下面这个判断：
   - 若这个数据页在 LRU 链表中存在的时间超过了 1 秒，就把它移动到链表头部；
   - 如果这个数据页在 LRU 链表中存在的时间短于 1 秒，位置保持不变。1 秒这个时间，是由参数 innodb_old_blocks_time 控制的。其默认值是 1000，单位毫秒。

> 在链表中存在的时间越长，说这个数据是被频繁访问的。

现在我们来分析一下改进之后的LRU算法对大表扫描的流程：

- 扫描过程中，需要新插入的数据页，都被放到 old 区域 ;
- 一个数据页里面有多条记录，这个数据页会被多次访问到，但由于是顺序扫描，这个数据页第一次被访问和最后一次被访问的时间间隔不会超过 1 秒，因此还是会被保留在 old 区域；
- 再继续扫描后续的数据，之前的这个数据页之后也不会再被访问到，于是始终没有机会移到链表头部（也就是 young 区域），很快就会被淘汰出去。

改进后最大的收益在于：扫描大表的过程中，虽然也用到了buffer pool，但是对young区域完全没有影响，从而保证了Buffer Pool响应正常业务的查询命中率。

## 小结

MySQL 采用的是边算边发的逻辑，因此对于数据量很大的查询结果来说，不会在 server 端保存完整的结果集。所以，如果客户端读结果不及时，会堵住 MySQL 的查询过程，但是不会把内存打爆。

而对于 InnoDB 引擎内部，由于有淘汰策略，大查询也不会导致内存暴涨。并且，由于 InnoDB 对 LRU 算法做了改进，冷数据的全表扫描，对 Buffer Pool 的影响也能做到可控。

## 参考

[MySQL 实战 45 讲-极客时间](https://time.geekbang.org/column/intro/100020801?tab=catalog)