---
title: MySQL深入12-count()
date: 2023-03-31 12:45:34
permalink: /pages/7162f3/
categories: 
  - MySQL
tags: 
  - MySQL
---
## MySQL深入-count(*)

在不同的MySQL引擎中，count(*)有不同的实现方式。

- MyISAM引擎是把一张表的总数存在了磁盘上，因此执行count（*）的时候直接返回这个表的总数就好了，速度非常快。
- InnoDB引擎在执行count（*）的时候需要把数据一行一行从引擎里面读出来，然后累加计算。

> 当然如果加了where条件的话，MyISAM的表返回总数也没那么快。

## InnoDB引擎为何不存表的总数

先有如下的例子：

![image-20220614091437577](https://blog-1300853183.cos.ap-chengdu.myqcloud.com/img/image-20220614091437577.png)

可以看到即使在同一时刻的多个查询语句，由于MVCC的原因，InnoDB引擎最后返回的总数是不相同的。每一行记录都要判断自己是否这个会话可见，因此对于count（*）来说，InnoDB只能一行一行去读再进行相应的判断。

但是虽然看起来麻烦的count（*），在执行操作的时候还是进行了优化的：

InnoDB是索引组织表，主键索引树的叶子节点存储的数据行，而普通索引树的叶子节点存储是主键值。所以，普通索引树比主键索引树小很多。对于count（*）这样的操作，无论是遍历主键索引树还是普通索引树得到的结果逻辑上是一样的，所以MySQL优化器会找到`最小`的那棵树进行遍历。

这里的最小的含义是：对于主键索引树而言，由于存储的是完整行信息，所以一个数据页其行密度比较小，最后导致要扫描的数据页更多，而对于非主键索引树而言，由于存储的是主键索引，所以一个数据页其行密度比较大，最终扫描的数据页较少，节省了IO开销。

**在保证逻辑正确的前提下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一。**

**show table status**

show table status 命令的输出结果里面也有一个 TABLE_ROWS 用于显示这个表当前有多少行,但是这个是不能代替count（*）的。这行命令和索引统计值类似，是采样估算出来的，存在误差。

**小结**

- MyISAM表虽然count（*）很快，但是不支持事务。
- show table status 命令虽然返回很快，但是不准确；
- InnoDB 表直接 count(*) 会遍历全表，虽然结果准确，但会导致性能问题。

那么如果我们有一个业务需要经常统计出一张大表的总数，该这么办呢？

## 缓存保存总数

我们可以使用Redis服务来保存这个表的总行数，这个表插入一条数据的时候Redis计数加1，删除一条数据的时候Redis计数减1。这种方式虽然读和写操作非常快，但是存在一些问题。

**问题1：丢失更新**

Redis数据不可能永远保存在内存中，所以我们会用到一些持久化操作把内存的数据存入到磁盘中。现在假设在上一次持久化过后，下一次持久化之前，我们往数据库中插入一条数据了，Redis保存的值也加了1，然后Redis重启了，重启之后的数据恢复是没有计算刚才插入的数据的，所以会存在丢失更新的情况。

当然这个问题是可以通过每次Redis重启后，去数据库里面执行一次count（*）获取当前最新的行数，再把这个值写回到 Redis 里就可以了。异常重启毕竟不是经常出现的情况，这一次全表扫描的成本，还是可以接受的。

**问题2：逻辑不精确**

假设有这么一个业务需求：查询总数的时候，还需要查询最新100条记录。一般来说，我们需要去Redis里面取到总数，然后再到数据库里面查询最新的100条记录。但是如果再高并发的情况下，就会存在如下两种不精确的情况：

- 查到的100行结果里面有最新插入的记录，但是Redis的计数没有加1
- 查到的100行结果里面没有最新插入的记录，但是Redis的计数已经加1

情况1：

![image-20220614095337569](https://blog-1300853183.cos.ap-chengdu.myqcloud.com/img/image-20220614095337569.png)



会话 A 是一个插入交易记录的逻辑，往数据表里插入一行 R，然后 Redis 计数加 1；会话 B 就是查询页面显示时需要的数据。再T3时刻进行查询，就会出现100行结果里面有最新的数据行，但是Redis的计数还没有加1。

情况2：

![image-20220614095556910](https://blog-1300853183.cos.ap-chengdu.myqcloud.com/img/image-20220614095556910.png)

现在把会话A的Redis操作和数据库操作更换一下顺序，那么T3时刻会话B就会存在100行结果里面没有最新的数据行，但是Redis的计数已经加1。

在并发系统里面，我们是无法精确控制不同线程的执行时刻的，所以会出现上诉两种情况，导致即使Redis正常工作，也会出现计数上的逻辑不精确。总的来说就是对于插入数据库与修改内存值的操作不是原子性的。这两个不同的存储构成的系统，不支持分布式事务，无法拿到精确一致的视图。

> 从并发系统性能的角度考虑，应该先插入操作记录，再更新计数表。

## 数据库保存计数

使用缓存保存计数会存在**丢失数据**和**计数不精确**的问题，那么我们可以尝试把这个计数直接存储到数据库单独的一张计数表中。

**丢失数据问题**

针对这个问题，由于InnoDB的redo log自带崩溃恢复功能，所以对于这个问题我们不需关心。

**计数不精确问题**

缓存计数不精确的问题在于两个数据库的操作不是同一个事务导致的。而对于数据库而言我们可以让读取计数器和查询最近数据在一个事务中。

![image-20220614100519958](https://blog-1300853183.cos.ap-chengdu.myqcloud.com/img/image-20220614100519958.png)

会话B中进行数据查询，由于会话A的事务还没有提交，所以会话B对于计数值加1这个操作是不可见的，因此在会话B中查计数值和“最近 100 条记录”看到的结果，逻辑上就是一致的。

## 不同count用法

count（）的语义：count() 是一个聚合函数，对于返回的结果集，一行行地判断，如果 count 函数的参数不是 NULL，累计值就加 1，否则不加。最后返回累计值。

count(*)、count(主键 id) 和 count(1) 都表示返回满足条件的结果集的总行数；而 count(字段），则表示返回满足条件的数据行里面，参数“字段”不为 NULL 的总个数。

**count（主键 id）**

InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加。

 **count （1）**

InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。

**count（字段）**

- 如果这个“字段”是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加；
- 如果这个“字段”定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加。

**count（*）**

并不会把全部字段取出来，而是专门做了优化，不取值。count(*) 肯定不是 null，按行累加。

**小结**

效率排序：count（字段）< count (id) < count(1) < count(*)

## 参考

[MySQL 实战 45 讲-极客时间](https://time.geekbang.org/column/intro/100020801?tab=catalog)